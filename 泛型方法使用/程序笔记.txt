
授课主题：C#泛型类和泛型方法 

一、泛型（Generic）

1、回顾前面：泛型集合List<T>、Dictionary<k,v>   所在命名空间：System.Collections.Generic;

比较非泛型：ArryList，Hastable      所在命名空间：System.Collections

经过刚才非泛型集合ArryList里面可以添加任意类型，我们发现，虽然是添加方便的。但是对于数据本身来讲，是非常不安全的。

因为我们开发中很多时候，这些是不可控的。其次，还存在拆装箱的问题。

装箱：将值类型的元素，放到集合中会被转换成object类型。这个过程就叫装箱。

拆箱：将一个集合中的元素取出来，但是这个元素本质是值类型，所以，我们必须强制类型转换。

弊端：如果我们存储大量的数据，我们会发现装箱和拆箱是影响程序性能的。（不测试）

实践应用中：我们发现，很少有情况去在一个集合中，添加任意的数据。

我们的需求：我们不希望在一个容器中，添加不同类型的数据，但是我们又希望这个容器能够根据我们的需求，随时决定能够添加何种类型的数据。

2、泛型出现-->泛型概念：泛型是一种程序特性，当我们使用泛型的时候，确切说定义的时候，是对这个类型不作出明确的规定，

    但是当我们使用的时候，必须明确规定，并且不能改变。

3、泛型出现的场合：泛型集合、泛型方法、泛型类、泛型委托...

二、泛型方法

1、为什么要使用泛型方法？

    public int  Add(int a,int b)
    {
        return a+b;
    }
    public double Add(double a,double  b)
    {
        return a+b;
    }
    //。。。

   基于前面的问题，我们可以定义成泛型方法。

2、泛型方法：就是把一个方法的返回值类型、方法参数定义成泛型类型。

    我们常见的泛型类型表示方法：T   T1、T2....

    练习1：泛型T，可以用于成员变量的定义类型、方法参数类型、方法返回值类型

3、default关键字

三、泛型约束

目的：就是对泛型类型做出数据类型的要求，或者其他的条件。



四、动态类型

dynamic：当我们希望某一个参数是“特定”类型的时，但是这个参数又被定义成泛型类型，泛型类型是不确定的。

所以在编译阶段，我们是不能这么直接使用的。不过，我们想，我传递数据的时候，肯定会符合你的要求。

所以，我们把数据类型的检查工作延迟到运行时，这时候dynamic就派上用场了。




















































